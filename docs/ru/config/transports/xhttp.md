# XHTTP: За гранью REALITY

Краткое описание разработки: В середине 2024 года, @mmmray @ll11l1lIllIl1lll и другие, основываясь на принципе "раздельная пакетная отправка, потоковая загрузка" и деталях реализации, описанных @RPRX, разработали SplitHTTP, впервые добившись обхода большинства промежуточных устройств, поддерживающих HTTP, без ущерба для эффективности загрузки, и впервые массово реализовали QUIC H3 через CDN, открыв новую эру.

Впоследствии были реализованы: Broswer Dialer, добавление отступов в заголовки для уменьшения сигнатуры (header padding), управление мультиплексированием (XMUX) и разблокировка REALITY. Затем разработку взял на себя @RPRX, реализовав настоящее разделение исходящего и входящего трафика и переименовав проект в XHTTP. Например, исходящий и входящий трафик могут быть IPv6 CDN H3 и IPv4 REALITY H2 соответственно (даже исходные IP-адреса могут различаться), и вот снова началась новая эра. Далее был разработан потоковый режим отправки (stream-up), не жертвующий эффективностью исходящего трафика, схема extra, позволяющая делиться всеми деталями конфигурации, и добавлена маскировка заголовков gRPC по умолчанию для режима stream-up, что позволило реализовать потоковую отправку H2 через CDN, заменив традиционный транспортный уровень gRPC, если бы мы знали, что это возможно, то не стали бы его создавать. Наконец, транспортный уровень HTTP был включен в XHTTP как режим stream-one, получив также header padding, XMUX, маскировку заголовков gRPC и другие функции. Таким образом, мы получили полноценный XHTTP: обход промежуточных устройств различными способами, разделение исходящего и входящего трафика, XMUX и все остальное, что только можно пожелать. Наступила эра всеобщего господства XHTTP.

Эта статья призвана помочь вам полностью понять принцип и дизайн XHTTP, чтобы вы могли лучше его использовать.
Если вы хотите пожертвовать проекту Xray или собираете NFT, соответствующая информация находится в конце статьи, спасибо за поддержку!

## Руководство по быстрому старту

Несмотря на большое количество параметров XHTTP, большинство из них имеют значения по умолчанию. Если вы просто хотите использовать XHTTP, следуйте этим шести шагам:

1.  Независимо от TLS или REALITY, обычно для настройки XHTTP достаточно указать только `path`, остальные параметры можно оставить пустыми.
2.  Если сервер поддерживает QUIC H3, клиент может использовать QUIC, выбрав `alpn` равным `"h3"`.
3.  Для выбора IP-адреса CDN в клиенте укажите IP-адрес в `address` и доменное имя в `serverName` (SNI).
4.  Если не удается подключиться к CF, включите поддержку gRPC на панели управления CF.
5.  Если не удается пройти через Nginx, измените `proxy_pass` на `grpc_pass` в конфигурации Nginx.
6.  Если не удается пройти через другие CDN или обратные прокси, рекомендуется выбрать `mode` равным `"packet-up"` для максимальной совместимости.

XHTTP по умолчанию использует мультиплексирование, что обеспечивает меньшую задержку, чем у Vision, но тесты скорости показывают худшие результаты, если не установлено `"maxConcurrency": 1`. См. раздел [XMUX](#xmuxobject).

CF обрывает HTTP-соединения без передачи данных в течение 100 секунд. Для поддержания активности долговременных соединений через прокси необходимо реализовать keep-alive на уровне приложения. Например, для SSH необходимо установить `ClientAliveInterval` в sshd.

Эта статья может служить расширенной документацией. Она охватывает практически все, что вы хотите знать о XHTTP, с объяснением каждого параметра. В конце статьи приведен пример конфигурации со всеми параметрами и описанием сценариев их использования. Если вам неясен какой-либо параметр, найдите его имя в тексте, чтобы найти подробное объяснение.

## Два базовых принципа

Так же, как REALITY может маскироваться под чужой веб-сайт, фундаментальная логика борьбы с цензурой заключается в увеличении «сопутствующего ущерба» для цензоров при блокировке, чтобы они не решались легко блокировать. Я в свое время делал ставку на TLS и запутывание временных и размерных характеристик трафика TLS по той же причине. Многолетний опыт показывает нам, что GFW не будет навсегда блокировать весь IP-адрес крупного CDN, иначе это затронет слишком много обычных веб-сайтов. Таким образом, для XHTTP наша первоначальная цель состояла в том, чтобы скрыть его за множеством различных CDN. Однако CDN, чтобы предотвратить атаки на исходный сервер, обычно кэшируют весь HTTP-запрос, прежде чем отправлять его на исходный сервер, за исключением специально поддерживаемых WS и gRPC. Многие промежуточные HTTP-устройства по умолчанию ведут себя аналогичным образом. Исходя из этого, протокол Meek от Tor упаковывает исходящий и входящий трафик в отдельные HTTP-запросы для обхода этих промежуточных устройств, но скорость ужасно низкая, потому что он не использует «потоковую загрузку» XHTTP. Что такое «потоковая загрузка»? Представьте, что вы загружаете большой файл с веб-сайта, и CDN не находит его в кэше, поэтому обращается к исходному серверу. Но, очевидно, он не будет кэшировать весь файл, как при загрузке, заставляя вас ждать, а будет немедленно передавать вам данные по мере их получения от исходного сервера. Это основа «потоковой загрузки» XHTTP, которая также гарантирует максимальную скорость загрузки. Что касается загрузки, то из соображений совместимости XHTTP сначала реализовал «пакетную загрузку», то есть упаковку исходящего трафика в отдельные POST-запросы. Его эффективность, очевидно, снижается, но, к счастью, для обычных прокси-серверов объем исходящего трафика очень мал. Позже я добавил «потоковую загрузку», и мы обнаружили, что с добавлением маскировки заголовка gRPC можно использовать потоковую загрузку H2 через CF, а после нескольких раундов оптимизации «пакетной загрузки» скорость даже приблизилась к «потоковой загрузке».

Кстати, о недавно ставшем популярным вопросе об «злоупотреблении» CDN: очевидно, что CDN, не поддерживающие потоковую загрузку, не предназначены для создания прокси-сервисов. Но для борьбы с GFW мы должны постоянно исследовать, разрабатывать и использовать как можно больше новых путей. Это разумно и необходимо, это вынужденная мера, и увеличение «сопутствующего ущерба» для цензоров требует от нас смешиваться с «нормальными» сервисами, что также неизбежно. Простейший пример: если в один прекрасный день будет введен белый список IP-адресов, и IP-адрес CDN окажется в нем, будете ли вы его использовать? В области борьбы с цензурой не применяются некоторые правила реального мира, но этот простой принцип многие до сих пор не понимают. Если вы все еще не поняли, то такой транспортный уровень, как WebSocket, сейчас существует только для обхода CDN. Как разработчик, вы можете удалить его, как пользователь, вы можете предложить разработчику удалить его, чтобы своими действиями доказать, что «злоупотребление CDN» — это не просто завистливая атака на Xray, которая является еще одним предлогом для удовлетворения нездоровой психологии, в то же время нетрудно заметить, что лицемерная сущность некоторых людей полностью раскрыта.

## PACKET-UP

Этот раздел содержит много технических деталей. Обычные пользователи могут прочитать только выделенный текст.

Для режима packet-up, обеспечивающего максимальную совместимость XHTTP («пакетная загрузка, потоковая выгрузка»), мы использовали следующую схему:

*   Клиент отправляет POST `/yourpath/sameUUID/seq` для передачи данных:
    *   UUID генерируется случайным образом и используется при запуске загрузки, чтобы сервер мог связать запросы. Если сервер не может связать запросы в течение 30 секунд, сеанс завершается.
    *   `seq` начинается с 0. Следующий POST-запрос можно отправлять только после отправки тела предыдущего (но не нужно ждать ответа).
    *   Несколько POST-запросов могут прийти на сервер в неправильном порядке. Сервер пересобирает их по `seq`. По умолчанию кэшируется до 30 запросов, превышение лимита приводит к разрыву соединения.
    *   Обратите внимание, что UUID и `seq` находятся в пути, а не в строке запроса, чтобы избежать странных проблем.
*   Клиент запускает загрузку с помощью GET `/yourpath/sameUUID`. Заголовок ответа сервера содержит:
    *   `X-Accel-Buffering: no`, чтобы сообщить промежуточным устройствам отключить буферизацию.
    *   `Cache-Control: no-store`, чтобы сообщить промежуточным устройствам не кэшировать данные.
    *   `Content-Type: text/event-stream` для маскировки под server-sent events (лучшая совместимость, можно отключить с помощью `noSSEHeader`).
    *   Для HTTP/1.1 также необходимо включить `Transfer-Encoding: chunked`, для H2/H3 это не требуется.
*   Чтобы избежать ограничений междоменных запросов при перенаправлении браузера Browser Dialer, заголовок ответа сервера для всех GET и POST-запросов содержит:
    *   `Access-Control-Allow-Origin: *`
    *   `Access-Control-Allow-Methods: GET, POST`
*   Для решения проблемы фиксированной длины заголовков HTTP-запросов и ответов:
    *   Заголовок запроса клиента по умолчанию содержит `Referer: ...?x_padding=XXX...` (Referer используется для предотвращения ненужных OPTIONS-запросов от Browser Dialer). Длина по умолчанию составляет 100-1000 символов, генерируется случайным образом для каждого запроса. Сервер по умолчанию проверяет, находится ли длина в допустимом диапазоне.
    *   Заголовок ответа сервера по умолчанию содержит `X-Padding: XXX....` Длина по умолчанию составляет 100-1000 символов, генерируется случайным образом для каждого ответа.
    *   Это то, что я неоднократно называл header padding, соответствующий параметр — `xPaddingBytes`.
    *   Размещение padding в Referer предложил @rPDmYQ, использование XXX также его идея. X в кодировке Хаффмана занимает 8 бит.

Пакетная загрузка и `Referer: ...?x_padding=XXX...` создают много длинных записей в журнале. Вы можете настроить обратный прокси-сервер, чтобы он не регистрировал их.

Кроме того, как и другие транспортные уровни Xray, сервер принимает заголовок `X-Forwarded-For` для получения реального IP-адреса клиента и проверяет `host`, отправленный клиентом, на основе настройки `host` на сервере (лично я рекомендую не устанавливать его без необходимости, так как он уже скрыт в пути).

Это упрощенный, необходимый процесс для режима packet-up. Однако остается один вопрос: как конкретно реализовать и ограничить POST-запросы? Для этого есть три специальных параметра (см. [ExtraObject](#extraobject)):

*   `scMaxEachPostBytes`: максимальный размер данных в каждом POST-запросе клиента.
*   `scMinPostsIntervalMs`: только для клиента, минимальный интервал между POST-запросами для одного прокси-запроса.
*   `scMaxBufferedPosts`: только для сервера, максимальное количество кэшируемых POST-запросов для одного прокси-запроса.

«Для одного прокси-запроса» означает, что каждый прокси-запрос имеет свой счетчик и не влияет на другие, даже если они находятся в одном H2/H3 соединении. Это значение `sc`, то есть sub-connection. Чтобы уменьшить отпечаток, первые два значения можно задать в виде диапазона, например, `"500000-1000000"` и `"10-50"` соответственно, со случайным выбором значения для каждого запроса. Эти параметры можно передать клиенту через `extra`, это описано в конце статьи. Кроме того, стоит отметить, что в последней версии Xray был оптимизирован packet-up, и его скорость теперь почти достигает stream-up, что особенно полезно для QUIC H3 через CDN.

## H1 / H2 / H3

Раз уж у нас есть режим packet-up, способный проходить практически через все промежуточные устройства, давайте обсудим кое-что интересное: QUIC H3 через CDN, то есть начало новой эры SplitHTTP. Понимание этого раздела особенно важно для гибкого использования XHTTP.

Особенностью многих HTTP-посредников, таких как CDN и Nginx, является преобразование версии HTTP. Например, они могут преобразовывать входящий трафик H3 в H1 или H2 при обращении к исходному серверу. Это означает, что наш сервер XHTTP может прослушивать только H1 и H2, без необходимости прослушивания H3, в то время как клиент XHTTP может использовать H3.

Это поведение по умолчанию для сервера XHTTP: прослушивание только TCP-порта и обработка трафика H1 и H2. При включении TLS и указании только `"h3"` в `alpn` сервер будет использовать quic-go для прослушивания UDP-порта и обработки трафика H3, но в настоящее время это не рекомендуется. Вместо этого следует скрывать XHTTP за реальными Nginx или Caddy, чтобы уменьшить цифровые отпечатки. Это одно из важных преимуществ XHTTP по сравнению с другими QUIC-прокси, другое, конечно, это возможность проходить через CDN. Кроме того, управление перегрузкой H3 реализовано на уровне приложения, теоретически вы можете изменить алгоритмы управления перегрузкой QUIC этих обратных прокси-серверов и скомпилировать их, чтобы реализовать агрессивную отправку пакетов, которую некоторые хотят.

Для клиента XHTTP:

*   При включении TLS/REALITY по умолчанию используется H2, в противном случае используется HTTP/1.1.
*   При включении TLS, если `alpn` содержит только `"http/1.1"`, используется HTTP/1.1 (но Xray не позволит изменить маскировку цифрового отпечатка браузера uTLS).
*   При включении TLS, если `alpn` содержит только `"h3"`, используется quic-go H3.
*   Однако при использовании Browser Dialer конкретная версия HTTP определяется браузером (весь `tlsSettings` игнорируется).

Если вам нужно узнать фактическую версию HTTP, используемую клиентом Xray, `host`, а также режим XHTTP, разделение загрузки и выгрузки и другую информацию, установите уровень ведения журнала `"info"`.

Проксирование QUIC H3 через CDN, по крайней
мере, XHTTP был первым, кто реализовал это в больших масштабах, открыв новый путь, ведь в некоторых регионах и у некоторых операторов связи цензура H3 не так строга, хотя у некоторых она может быть очень жесткой. Даже после того, как мы разработали режим stream-up и обнаружили, что можно проходить через CF с помощью маскировки заголовка gRPC, это работало только для H2, похоже, ценность этой новой эры продолжает расти.

## XMUX

Раз уж мы упомянули H2 и H3, нельзя не упомянуть их мультиплексирование: оба имеют 0-RTT. Разница в том, что у H3 нет проблемы блокировки головки TCP, как у H2, и он поддерживает миграцию соединения, поэтому переключение сети на стороне клиента не приведет к разрыву соединения. Тогда те, кто часто изучает RFC, спросят: как конкретно управлять их мультиплексированием? Мы разработали простой и мощный интерфейс, XMUX (см. [XMUXObject](#xmuxobject) для деталей конфигурации).

Параметры XMUX можно комбинировать различными способами. Например, для многопоточного тестирования скорости необходимо установить `"maxConcurrency": 1`, а для «бесконечного» повторного использования можно установить `"maxConnections": 1`. Даже если вам лень разбираться, когда все эти значения равны 0, используются три описанных выше значения по умолчанию, что эквивалентно периодической смене основного H2/H3 соединения, что довольно удобно. Это позволяет избежать «обрывов» соединения, которые могут возникать при постоянном использовании одного и того же соединения для gRPC или HTTP. Аналогично, эти параметры можно передать клиенту через `extra`.

Примечание: отсутствие значений эквивалентно нулевым значениям, будут использованы три значения по умолчанию. Но если указан хотя бы один параметр, остальные параметры не имеют значений по умолчанию и должны быть указаны явно, за исключением первых двух параметров (`maxConcurrency` и `maxConnections`, из которых только один может быть использован). Все остальные параметры можно указывать одновременно.

Кроме того, при использовании XHTTP не следует включать `mux.cool`. Новая версия сервера Xray имеет проверку и принимает только чистый XUDP.

Некоторые выдержки о значениях по умолчанию XMUX:

*   Я специально выбрал два параметра, которые не так заметны вне TLS, а именно `maxConcurrency` и `cMaxReuseTimes` (а не `maxConnections` и `cMaxLifetimeMs`), и значения по умолчанию для этих параметров являются диапазоном со случайным выбором, что максимально устраняет потенциальные признаки.
*   Я выбрал `maxConcurrency` вместо `maxConnections`, чтобы предотвратить появление фиксированного шаблона количества соединений. Конечно, если вам нравится второй вариант, вы можете установить его вручную.
*   XMUX и Nginx имеют разные объекты подсчета. `maxConcurrency` и `cMaxReuseTimes` основаны на подсчете «проксируемых соединений». Только stream-one генерирует один HTTP-запрос, stream-up — два (один для загрузки, один для выгрузки), а packet-up — N.
*   Однако я не уверен, что stream-one не будет генерировать дополнительные HTTP-запросы в некоторых случаях. Кроме того, я считаю, что стремление к повторному использованию одного соединения до конца не имеет большого смысла, потому что если бы вы были оператором связи, вы бы также ограничивали скорость и очищали старые соединения, иначе ресурсы были бы постепенно заняты старыми соединениями. Поэтому параметры XMUX по умолчанию ограничивают повторное использование и периодически меняют соединения.

Далее в статье обсуждаются некоторые параметры Nginx.

## STREAM-UP/ONE

Наконец, очередь дошла до другого важного режима XHTTP: "потоковая загрузка, потоковая выгрузка" (stream-up). Как следует из названия, в этом режиме загрузка также является потоковой, что не снижает ее эффективность. Он был первоначально разработан для REALITY, пока мы не обнаружили, что маскировка заголовка gRPC под H2 позволяет проходить через CF (необходимо включить поддержку gRPC в панели управления), и обратные прокси-серверы, такие как Nginx, также хорошо его поддерживают (для Nginx рекомендуется `grpc_pass`, это просто и удобно). Поэтому поведение `mode` со значением по умолчанию `"auto"` следующее:

*   Клиент: `stream-up` для TLS H2, `stream-one` для REALITY (stream-up при наличии `downloadSettings`), в противном случае `packet-up`.
*   Сервер: по умолчанию принимает все три режима. Если задан конкретный режим, принимается только он. `"stream-up"` является исключением, он также принимает `stream-one`.
*   `stream-up` имеет немного лучшую совместимость, чем `stream-one`. Участники группы сообщали, что CFT с включенной потоковой загрузкой может использовать `stream-up`, но требуется включить еще одну опцию для использования `stream-one` (возможно, проблема в маскировке SSE?). Также видел CDN (забыл название), который сильно ограничивал скорость `stream-one`, но не `stream-up`.

Способы их реализации (не разработчики могут пропустить):

*   Для `stream-up` достаточно заменить пакетную загрузку `packet-up` на потоковую POST `/yourpath/sameUUID`. Также используется `Referer: ...?x_padding=XXX...`.
*   Для `stream-one` используется POST `/yourpath/`. Ответ является выгрузкой, двунаправленный поток. Заголовки запроса и ответа имеют header padding.
*   Обратите внимание, что если для `stream-one` указан `/yourpath`, фактический запрос отправляется на `/yourpath/`. Если `/` в конце отсутствует, он добавляется автоматически.
*   Загрузка по умолчанию имеет `Content-Type: application/grpc` для маскировки под gRPC (можно отключить с помощью `noGRPCHeader`).
*   Заголовки ответа сервера для выгрузки идентичны заголовкам `packet-up` из пункта 1. В `stream-one` может возникнуть необычная ситуация, когда gRPC отвечает с помощью SSE. Если возникнут проблемы, попробуйте `noSSEHeader`.
*   В ходе тестов, связанных с #4113 (comment), было обнаружено, что CF обрывает HTTP-соединения без передачи данных в течение 100 секунд, что приводит к обрыву загрузки `stream-up`. Поэтому был добавлен параметр `scStreamUpServerSecs` на сервер (см. [ExtraObject](#extraobject)) со значением по умолчанию `"20-80"` (выбирается случайным образом). Сервер каждые этот интервал отправляет `xPaddingBytes` байт для поддержания активности соединения.
    *   Можно установить `"scStreamUpServerSecs": -1`, чтобы отключить этот механизм. В этом случае сервер даже не будет отправлять заголовки ответа своевременно, как в предыдущих версиях.

Тогда те, кто часто использует gRPC, спросят: какие преимущества имеет `stream-up` по сравнению с транспортным уровнем gRPC?

*   Первому не нужны никакие библиотеки gRPC, производительность выше.
*   Исходящий трафик первого — это отдельные GET-запросы, не подверженные ограничениям CDN для трафика gRPC.
*   Первый также имеет header padding, XMUX, разделение загрузки и выгрузки и другие улучшения, и уже внедрен механизм `extra`, все параметры можно передавать, более зрелое решение.

Конечно, преимущества XHTTP по сравнению с WebSocket и HTTPUpgrade, помимо «отсутствия явного признака ALPN как http/1.1», вы, дочитав до этого места, уже наверняка поняли сами, и я не буду их перечислять, в основном потому, что их слишком много.

## Разделение загрузки и выгрузки

И, наконец, еще одна новая эра: разделение загрузки и выгрузки. Мы примерно знаем, что сейчас GFW обнаруживает такие характеристики трафика, как TLS in TLS, на основе одного соединения. Таким образом, если мы разделим загрузку и выгрузку на разные соединения, например, загрузка будет идти по TCP через IPv4, а выгрузка — по UDP через IPv6, GFW не сразу сможет сориентироваться. А поскольку сервер XHTTP связывает загрузку и выгрузку только на основе случайно сгенерированного UUID в пути, `packet-up` и `stream-up` изначально обладают настоящей способностью разделять загрузку и выгрузку. И поскольку XHTTP может проходить через различные CDN, может сочетаться с REALITY и другими технологиями, количество возможных вариантов бесконечно. Для клиента необходимо настроить `downloadSettings` (см. [DownloadSettingsObject](#downloadsettingsobject)).

Как видно, `downloadSettings` — это, по сути, новый набор `streamSettings`, но с добавлением `address` и `port`, аналогичных исходящему VLESS, для указания другого входа. Очевидно, что `network` должен быть `"xhttp"` (нельзя опускать), `security` может быть `"tls"` или `"reality"`. Параметр `sockopt` также можно передавать, но принимающая сторона может установить `penetrate` в значение `true` в `sockopt` загрузки, чтобы переопределить выгрузку, что подходит для использования `mark`. За исключением этого особого случая, при разделении загрузки и выгрузки конфигурация выгрузки полностью независима и не наследует никакие настройки загрузки. Более того, например, даже если XMUX не указан ни для загрузки, ни для выгрузки, и используются значения по умолчанию, фактические значения, выбранные случайным образом из диапазона, независимы друг от друга. Таким образом, со временем повторное использование загрузки и выгрузки становится полностью асимметричным, моменты переключения основного соединения также различаются, что улучшает защиту от анализа. Поскольку, если GFW захочет бороться с разделением загрузки и выгрузки, «одинаковое время запуска основного соединения» определенно будет самой важной точкой входа. Поэтому в будущем XHTTP позволит запускать соединения загрузки и выгрузки в разное время с самого начала.

На самом деле, если вы используете CDN, вы можете использовать разделение загрузки и выгрузки, даже не изменяя конфигурацию сервера. Например, вы можете выбрать IPv4 для TLS H2 и IPv6 для QUIC H3. Кроме того, CDN обычно поддерживают «префикс одного домена». Например, `serverName` для загрузки может быть `"a.example.com"`, `serverName` для выгрузки — `"b.example.com"`, а `host` для обоих — `"c.example.com"`. Это позволяет сделать внешние SNI разными. Конечно, если у вас уже есть два домена, это еще лучше. Если у вас нет доменов, вы можете использовать два VPS и два REALITY для разделения загрузки и выгрузки: будь то CDN с обратным прокси или REALITY с fallback, главное, чтобы в итоге трафик с одним и тем же путем попадал на один и тот же входящий XHTTP на одном и том же VPS. В общем, поскольку XHTTP можно использовать везде, количество возможных комбинаций бесконечно. Единственный вопрос — насколько развита ваша фантазия.

Например, после появления разделения загрузки и выгрузки многие используют его для разделения загрузки на канал с лучшим исходящим трафиком, а выгрузки — на канал с лучшим входящим трафиком, что также довольно практично.

Например, вы можете установить `"maxConnections": 1` для загрузки и `"maxConcurrency": 1` для выгрузки, чтобы небольшой объем данных загрузки шел по одному и тому же базовому соединению, а большой объем данных выгрузки распределялся по разным базовым соединениям, одновременно обеспечивая защиту от цензуры, низкую задержку и высокую скорость. Это похоже на Switch, и лучше всего работает в сочетании с Vision Seed.

## XHTTPSettingsObject

`XHTTPSettingsObject` соответствует элементу `xhttpSettings` в конфигурации транспорта.

```json
{
  "host": "example.com",
  "path": "/yourpath",
  "mode": "auto",
  "extra": {
    "headers": {
      // "key": "value"
    },
    "xPaddingBytes": "100-1000",
    "noGRPCHeader": false,
    "noSSEHeader": false,
    "scMaxEachPostBytes": 1000000,
    "scMinPostsIntervalMs": 30,
    "scMaxBufferedPosts": 30,
    "scStreamUpServerSecs": "20-80",
    "xmux": {
      "maxConcurrency": "16-32",
      "maxConnections": 0,
      "cMaxReuseTimes": 0,
      "hMaxRequestTimes": "600-900",
      "hMaxReusableSecs": "1800-3000",
      "hKeepAlivePeriod": 0
    },
    "downloadSettings": {
      "address": "",
      "port": 443,
      "network": "xhttp",
      "security": "tls",
      "tlsSettings": {
        // ...
      },
      "xhttpSettings": {
        "path": "/yourpath"
        // ... другие параметры XHTTPSettingsObject для скачивания
      },
      "sockopt": {}
    }
  }
}
```

> `host`: string

Имя хоста, отправляемое в HTTP-заголовке `Host`.
Поведение `host` аналогично другим транспортным уровням Xray, основанным на HTTP. Приоритет отправки `host` клиентом: `host` > `serverName` (из `tlsSettings`) > `address` (из `streamSettings`).
Если на сервере установлен `host`, он проверяет, совпадает ли значение, отправленное клиентом. В противном случае проверка не выполняется. Рекомендуется не устанавливать его без необходимости, так как путь (`path`) уже обеспечивает некоторую маскировку.
`host` нельзя указывать в `extra.headers`.
Значение по умолчанию: `""` (пустая строка).

> `path`: string

Путь HTTP-запроса. Должен быть одинаковым для клиента и сервера, а также для основного потока и потока `downloadSettings` при разделении загрузки/выгрузки.
Например: `"/yourpath"`.
Значение по умолчанию: `""` (пустая строка, но обычно требуется указать).

> `mode`: string

Режим работы XHTTP. Возможные значения:
*   `"auto"`: Режим выбирается автоматически.
    *   Клиент: `stream-up` для TLS H2, `stream-one` для REALITY (или `stream-up` при наличии `downloadSettings`), в противном случае `packet-up`.
    *   Сервер: по умолчанию принимает все три режима (`packet-up`, `stream-up`, `stream-one`).
*   `"packet-up"`: Режим "пакетная загрузка, потоковая выгрузка". Максимальная совместимость.
*   `"stream-up"`: Режим "потоковая загрузка, потоковая выгрузка". Использует два HTTP-запроса (один для загрузки, один для выгрузки). Сервер, настроенный на `stream-up`, также принимает `stream-one`.
*   `"stream-one"`: Режим "потоковая загрузка, потоковая выгрузка" в одном HTTP-запросе.
Значение по умолчанию: `"auto"`.

> `extra`: [ExtraObject](#extraobject)

Дополнительные параметры конфигурации. Когда `extra` присутствует, на верхнем уровне `xhttpSettings` действуют только `host`, `path`, `mode` и сам `extra`. Параметры внутри `extra` используются относительно редко и обычно предоставляются клиенту поставщиком услуг.
Значение по умолчанию: отсутствует (эквивалентно пустому объекту `{}`).

### ExtraObject

`ExtraObject` соответствует полю `extra` в `XHTTPSettingsObject`.

```json
{
  "headers": {
    // "key": "value"
  },
  "xPaddingBytes": "100-1000",
  "noGRPCHeader": false,
  "noSSEHeader": false,
  "scMaxEachPostBytes": 1000000,
  "scMinPostsIntervalMs": 30,
  "scMaxBufferedPosts": 30,
  "scStreamUpServerSecs": "20-80",
  "xmux": {
    // ... см. XMUXObject
  },
  "downloadSettings": {
    // ... см. DownloadSettingsObject
  }
}
```

> `headers`: map{string, string}

Пользовательские HTTP-заголовки, которые будут добавлены к каждому запросу.
Ключ — имя заголовка, значение — значение заголовка.
Например: `{ "User-Agent": "MyCustomClient" }`.
Нельзя указывать заголовок `Host` здесь, используйте поле `host` в `XHTTPSettingsObject`.
Значение по умолчанию: `{}` (пустой объект).

> `xPaddingBytes`: string

Размер случайного заполнения (padding) в байтах, добавляемого в HTTP-заголовки для затруднения анализа трафика.
Может быть указано как одно число (например, `"200"`) или диапазон (например, `"100-1000"`), из которого будет выбрано случайное значение.
Заполнение добавляется в заголовок `Referer` для запросов и `X-Padding` для ответов.
Значение по умолчанию: `"100-1000"`.

> `noGRPCHeader`: true | false

Только для клиента, в режимах `stream-up` и `stream-one`.
Если `true`, отключает добавление заголовка `Content-Type: application/grpc` для маскировки под gRPC.
Значение по умолчанию: `false`.

> `noSSEHeader`: true | false

Только для сервера.
Если `true`, отключает добавление заголовка `Content-Type: text/event-stream` для маскировки под Server-Sent Events (SSE) в ответах сервера.
Может быть полезно, если возникают проблемы совместимости, например, в режиме `stream-one`, где gRPC-подобный запрос может получать SSE-подобный ответ.
Значение по умолчанию: `false`.

> `scMaxEachPostBytes`: integer | string

Только для режима `packet-up`. Максимальный размер данных (в байтах) в каждом POST-запросе клиента.
Должен быть меньше максимального размера, разрешенного CDN и промежуточными HTTP-устройствами.
Сервер также отклоняет POST-запросы, превышающие этот размер.
Может быть указано как целое число или строка, представляющая диапазон (например, `"500000-1000000"`), из которого будет выбрано случайное значение.
Значение по умолчанию: `1000000` (1 МБ).

> `scMinPostsIntervalMs`: integer | string

Только для режима `packet-up` и только для клиента. Минимальный интервал (в миллисекундах) между отправкой последовательных POST-запросов для одного прокси-соединения.
Может быть указано как целое число или строка, представляющая диапазон (например, `"10-50"`), из которого будет выбрано случайное значение.
Значение по умолчанию: `30`.

> `scMaxBufferedPosts`: integer

Только для режима `packet-up` и только для сервера. Максимальное количество POST-запросов от клиента, которые сервер может буферизовать для одного прокси-соединения. Превышение лимита приводит к разрыву соединения.
Значение по умолчанию: `30`.

> `scStreamUpServerSecs`: string | integer

Только для режима `stream-up` и только для сервера. Интервал (в секундах), через который сервер будет отправлять пакеты заполнения (`xPaddingBytes`) для поддержания активности соединения загрузки (download).
Это необходимо, так как некоторые прокси (например, Cloudflare) могут обрывать неактивные HTTP-соединения.
Может быть указано как строка, представляющая диапазон (например, `"20-80"`), из которого будет выбрано случайное значение, или целое число.
Значение `-1` отключает этот механизм.
Значение по умолчанию: `"20-80"`.

> `xmux`: [XMUXObject](#xmuxobject)

Настройки мультиплексирования соединений (в основном для H2/H3). Только для клиента.
Значение по умолчанию: `{}` (пустой объект, при этом применяются специфические значения по умолчанию для полей `XMUXObject`, если ни одно из них не указано).

> `downloadSettings`: [DownloadSettingsObject](#downloadsettingsobject)

Только для клиента. Конфигурация для разделения потока загрузки (download) на отдельное соединение.
Если указано, исходящий трафик (upload) будет использовать основную конфигурацию `xhttpSettings`, а входящий трафик (download) — эту.
Значение по умолчанию: отсутствует.

#### XMUXObject

`XMUXObject` соответствует полю `xmux` в `ExtraObject`. Эти настройки в основном актуальны для HTTP/2 и HTTP/3 и применяются на стороне клиента.

```json
{
  "maxConcurrency": "16-32",
  "maxConnections": 0,
  "cMaxReuseTimes": 0,
  "hMaxRequestTimes": "600-900",
  "hMaxReusableSecs": "1800-3000",
  "hKeepAlivePeriod": 0
}
```
::: tip
Если ни один из параметров `XMUXObject` не указан (т.е. `xmux: {}` или `xmux` отсутствует), то для `maxConcurrency`, `hMaxRequestTimes` и `hMaxReusableSecs` будут использованы значения по умолчанию, указанные ниже. Если хотя бы один параметр `XMUXObject` указан, то для остальных неуказанных параметров значения по умолчанию будут `0` (или специфичные для параметра, если `0` не является стандартным отсутствием ограничения).
`maxConcurrency` и `maxConnections` конфликтуют, можно использовать только один из них.
:::

> `maxConcurrency`: string | integer

Максимальное количество одновременных прокси-запросов в каждом TCP/QUIC-соединении. Когда количество прокси-запросов в соединении достигает этого значения, ядро устанавливает новое соединение.
Может быть указано как целое число или строка, представляющая диапазон (например, `"16-32"`), из которого будет выбрано случайное значение.
Значение по умолчанию: `"16-32"`, если все параметры XMUX не заданы. В противном случае, если `maxConnections` не задан, то `0` (без ограничений, но обычно не рекомендуется).

> `maxConnections`: integer | string

Максимальное количество одновременных TCP/QUIC-соединений. До достижения этого значения каждый новый прокси-запрос открывает новое соединение. После этого ядро начинает повторно использовать существующие соединения.
Этот параметр конфликтует с `maxConcurrency`.
Может быть указано как целое число или строка, представляющая диапазон, из которого будет выбрано случайное значение.
Значение по умолчанию: `0` (без ограничений).

> `cMaxReuseTimes`: integer | string

Максимальное количество раз, которое одно TCP/QUIC-соединение может быть повторно использовано для новых прокси-запросов. После достижения этого лимита соединение больше не будет использоваться для новых прокси-запросов и будет закрыто после завершения последнего активного прокси-запроса.
Подсчет основан на количестве "проксируемых соединений".
Может быть указано как целое число или строка, представляющая диапазон, из которого будет выбрано случайное значение.
Значение по умолчанию: `0` (без ограничений).

> `hMaxRequestTimes`: string | integer

Максимальное количество HTTP-запросов на каждом TCP/QUIC-соединении. Например, Nginx по умолчанию разрешает 1000 запросов.
Подсчет HTTP-запросов: `stream-one` генерирует 1 HTTP-запрос, `stream-up` — 2, `packet-up` — N. Подсчет не является точным.
Если при циклической отправке POST-запросов в режиме `packet-up` это значение превышено, происходит автоматическое переключение на другое TCP/QUIC-соединение.
Может быть указано как целое число или строка, представляющая диапазон (например, `"600-900"`), из которого будет выбрано случайное значение.
Значение по умолчанию: `"600-900"`, если все параметры XMUX не заданы. В противном случае `0` (без ограничений).

> `hMaxReusableSecs`: string | integer

Максимальное время (в секундах), в течение которого TCP/QUIC-соединение может быть повторно использовано для новых HTTP-запросов. Например, Nginx по умолчанию разрешает повторное использование в течение одного часа.
Соединение, существующее дольше этого времени, не будет использоваться для новых HTTP-запросов и будет закрыто после завершения последнего HTTP-запроса.
Если при циклической отправке POST-запросов в режиме `packet-up` это значение превышено, происходит автоматическое переключение на другое TCP/QUIC-соединение.
Может быть указано как целое число или строка, представляющая диапазон (например, `"1800-3000"`), из которого будет выбрано случайное значение.
Значение по умолчанию: `"1800-3000"`, если все параметры XMUX не заданы. В противном случае `0` (без ограничений).

> `hKeepAlivePeriod`: integer

Интервал (в секундах), через который клиент отправляет keep-alive пакет (HTTP PING frame) в неактивном H2/H3 соединении.
Значение `0` соответствует поведению по умолчанию: 45 секунд для Chrome H2 или 10 секунд для quic-go H3.
Отрицательное значение (например, `-1`) отключает отправку keep-alive пакетов в неактивном состоянии.
Этот параметр не допускает указание диапазона.
Значение по умолчанию: `0`.

#### DownloadSettingsObject

`DownloadSettingsObject` соответствует полю `downloadSettings` в `ExtraObject`. Используется для настройки отдельного потока для скачивания (входящего трафика к клиенту). Это, по сути, стандартная конфигурация `streamSettings` Xray.

```json
{
  "address": "",
  "port": 443,
  "network": "xhttp",
  "security": "tls",
  "tlsSettings": {
    // ... стандартные tlsSettings
  },
  "xhttpSettings": {
    "path": "/yourpath" // должен быть таким же, как и в основной конфигурации
    // ... другие параметры XHTTPSettingsObject, специфичные для скачивания,
    // например, mode, extra (но без вложенного downloadSettings)
  },
  "sockopt": {
    // ... стандартные sockopt
  }
}
```

> `address`: string

Адрес сервера для потока скачивания (может быть IP-адресом или доменным именем, отличным от основного соединения).
Значение по умолчанию: `""` (пустая строка).

> `port`: integer

Порт сервера для потока скачивания.
Значение по умолчанию: `443`.

> `network`: string

Тип сети. Для разделения потоков XHTTP **должен** быть `"xhttp"`.
Значение по умолчанию: отсутствует (должен быть указан как `"xhttp"`).

> `security`: string

Тип безопасности соединения. Может быть `"tls"` или `"reality"`.
Значение по умолчанию: отсутствует (должен быть указан).

> `tlsSettings`: object

Настройки TLS, если `security` установлено в `"tls"`. Стандартный объект `tlsSettings` Xray.
Значение по умолчанию: `{}`.

> `xhttpSettings`: [XHTTPSettingsObject](#xhttpsettingsobject)

Специфичные настройки XHTTP для потока скачивания. Это вложенный `XHTTPSettingsObject`.
**Важно:** `path` в этом объекте должен совпадать с `path` в основной конфигурации `XHTTPSettingsObject`.
Другие параметры, такие как `mode` или `extra` (включая `xmux`, но не рекурсивный `downloadSettings`), могут быть настроены независимо для потока скачивания.
Значение по умолчанию: `{}`.

> `sockopt`: object

Настройки сокета. Стандартный объект `sockopt` Xray.
Особый случай: если в `sockopt` потока скачивания `penetrate` установлено в `true`, то `sockopt` потока скачивания переопределит `sockopt` потока загрузки (полезно для `mark`).
Значение по умолчанию: `{}`.
